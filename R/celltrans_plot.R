#' Plotting data points and the corresponding predictions of CellTrans.
#' 
#' This function allows to create plots of the predictions of CellTrans together with the experimental data. The variable input contains the read data from readExperimentalData(). One can choose the experiments for which the plot is created.
#' @param input A datalist generated by the function readExperimentaldata().
#' @keywords plot
#' @export
#' @examples
#' celltrans_plot
#' 

celltrans_plot <- function(expData, timepoints, datapoints, tau, cellnr, cell_types, timeunits) {
  
  #timepoints<-dlgList(title="Data point(s) for estimation",multiple=TRUE, choices=timepoints)$res  
  
  trMatrix=calculate_transitionMatrix(expData, timepoints, datapoints, tau)
  
  controltime=0
  #control<-dlgList(title="Plot experimental equilibrium?", choices=c("yes","no"))$res
  control <- "no"
  if(control=="yes") {
    
    controlvector=matrix(scan(dlgOpen(title = paste0("Select file with experimental equilibrium distribution."))$res, n = cellnr), nrow=1, byrow = TRUE)
    while (!isTrMatrix(controlvector)) 
    { dlgMessage(paste("Try again! Selected file does not contain an experimental control vector of dimension ",cellnr," !"))
      controlvector=matrix(scan(dlgOpen(title = paste0("Select file with control distribution."))$res, n = cellnr), nrow=1, byrow = TRUE)
      
    }
    controltime<-as.double(dlgInput("Time point of equilibrium")$res)
    
    
  }
  
  

  
  #initExp <- as.integer(dlgList(title="Plot experiment(s)...",multiple=TRUE, choices=c(1:cellnr))$res)
  initExp <- c(1:cellnr)
  
  #statestoplot <- dlgList(title="Plot cell state(s)...",multiple=TRUE, choices=cell_types)$res
  statestoplot <- cell_types
  
  # Choose position of states in cell_types vector
  statestoplot <- which(cell_types == statestoplot)
  
  #y_bis <- as.double(dlgInput("Range of y-value for plot")$res)
  y_bis <- 1

  
  maxtime=max(timepoints,controltime)
  
  colors=rainbow(cellnr)
  #ADAPT colors:
  #colors=c(rgb(192/255,0,0),rgb(1,0,0),rgb(1,80/255,80/255),rgb(1,124/255,128/255),rgb(32/255,56/255,100/255),rgb(0,102/255,1),rgb(0,176/255,249/255),rgb(204/255,1,1),rgb(56/255,87/255,35/255),rgb(84/255,130/255,53/255),rgb(146/255,208/255,80/255),rgb(197/255,224/255,180/255),rgb(191/255,144/255,0),rgb(1,192/255,0),rgb(1,1,0),rgb(1,1,204/255))
  
  
  for (k in initExp) {
    initialcelldistr=expData[k, ]
    plot(main=paste0("Experiment with initial distribution \n(", paste(cell_types,collapse=", "),") = (",paste(initialcelldistr,collapse = ", "),")"),1,1,type="n",xlab=timeunits, ylab=paste("fraction of cells"),ylim=c(0,y_bis),xlim=c(0,maxtime),cex.main=0.8)
    for (step in 1:maxtime) {
      data=rbind2(initialcelldistr,t(sapply(1:maxtime,
                                            function (step) {initialcelldistr %*% (trMatrix %^% (step/tau))})))[,statestoplot]
    }
    matplot(add=T,x=c(0:maxtime),y=data,lty=1,type="l",lwd=2,col=colors[statestoplot])
    legend("topright",lwd="2", legend=cell_types[statestoplot],col=colors[statestoplot])
    #plot datapoints
    
    for (i in statestoplot) {
      #plot initial distribution
      points(0,expData[k,i],col=colors[i],lwd=2,pch=21,bg=colors[i])
      #plot datapoints
      for (j in 1:length(timepoints)) {
        points(timepoints[j],expData[j*cellnr+k,i],col=colors[i],lwd=2,pch=21,bg=colors[i])
      }
      if (control=="yes") {
        points(controltime,controlvector[i],col=colors[i],lwd=2,pch=21,bg=colors[i])
        
      }
    }
  }
}
